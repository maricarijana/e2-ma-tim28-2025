package com.example.teamgame28.repository;

import android.content.Context;
import android.util.Log;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;

import com.example.teamgame28.model.Task;
import com.example.teamgame28.model.TaskStatus;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.QueryDocumentSnapshot;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TaskRepository {
    private static TaskRepository instance;

    private final FirebaseFirestore db = FirebaseFirestore.getInstance();
    private static final String COLLECTION_NAME = "tasks";

    // Callback za XP dodelu (poziva ga TaskService)
    public interface OnTaskFinishedListener {
        void onTaskFinished(String userId, int xpAmount);
    }

    private OnTaskFinishedListener taskFinishedListener;

    // ‚úÖ Singleton (da mo≈æe≈° zvati getInstance)
    private TaskRepository(Context context) { }

    public static TaskRepository getInstance(Context context) {
        if (instance == null) {
            instance = new TaskRepository(context.getApplicationContext());
        }
        return instance;
    }

    public void setOnTaskFinishedListener(OnTaskFinishedListener listener) {
        this.taskFinishedListener = listener;
    }

    // ‚úÖ Dohvatanje svih zadataka (za TaskListFragment)
    public LiveData<List<Task>> getAllTasks() {
        MutableLiveData<List<Task>> liveData = new MutableLiveData<>();

        db.collection(COLLECTION_NAME)
                .addSnapshotListener((querySnapshot, e) -> {
                    if (e != null || querySnapshot == null) {
                        liveData.setValue(new ArrayList<>());
                        return;
                    }

                    List<Task> tasks = new ArrayList<>();
                    for (QueryDocumentSnapshot document : querySnapshot) {
                        Task task = document.toObject(Task.class);
                        tasks.add(task);
                    }
                    liveData.setValue(tasks);
                });

        return liveData;
    }

    // ‚úÖ Ako ti treba filtrirano po korisniku
    public LiveData<List<Task>> getTasksByUser(String userId) {
        MutableLiveData<List<Task>> liveData = new MutableLiveData<>();

        db.collection(COLLECTION_NAME)
                .whereEqualTo("userId", userId)
                .addSnapshotListener((querySnapshot, e) -> {
                    if (e != null || querySnapshot == null) {
                        liveData.setValue(new ArrayList<>());
                        return;
                    }

                    List<Task> tasks = new ArrayList<>();
                    for (QueryDocumentSnapshot document : querySnapshot) {
                        Task task = document.toObject(Task.class);
                        tasks.add(task);
                    }
                    liveData.setValue(tasks);
                });

        return liveData;
    }

    // ‚úÖ Dodavanje zadatka
    public void addTask(Task task) {
        String id = db.collection(COLLECTION_NAME).document().getId();
        task.setId(id);
        db.collection(COLLECTION_NAME)
                .document(id)
                .set(task);
    }
    public void updateTask(Task task) {
        db.collection(COLLECTION_NAME)
                .document(task.getId())
                .set(task);
    }

    public void addTaskWithXpLimit(Task task) {
        Log.d("XP_DEBUG", "‚û°Ô∏è Dodajem task: " + task.getTitle());

        Calendar start = Calendar.getInstance();
        Calendar end = Calendar.getInstance();

        int maxCount = getXpLimit(task);

        // ‚è∞ Odredi vremenski period kvote
        if (isDaily(task)) {
            start.set(Calendar.HOUR_OF_DAY, 0);
            start.set(Calendar.MINUTE, 0);
            start.set(Calendar.SECOND, 0);
            end = (Calendar) start.clone();
            end.add(Calendar.DAY_OF_MONTH, 1);
        } else if (isWeekly(task)) {
            start.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
            start.set(Calendar.HOUR_OF_DAY, 0);
            start.set(Calendar.MINUTE, 0);
            start.set(Calendar.SECOND, 0);
            end = (Calendar) start.clone();
            end.add(Calendar.WEEK_OF_YEAR, 1);
        } else if (isMonthly(task)) {
            start.set(Calendar.DAY_OF_MONTH, 1);
            start.set(Calendar.HOUR_OF_DAY, 0);
            start.set(Calendar.MINUTE, 0);
            start.set(Calendar.SECOND, 0);
            end = (Calendar) start.clone();
            end.add(Calendar.MONTH, 1);
        }

        Log.d("XP_DEBUG", "üïí Period: " + start.getTime() + " ‚Üí " + end.getTime());
        Log.d("XP_DEBUG", "üìä Kvota dozvoljena: " + maxCount);

        // üßÆ Defini≈°i "tip" zadatka po te≈æini i bitnosti
        int diff = task.getDifficultyXp();
        int imp = task.getImportanceXp();

        // üîç Napravi query koji broji koliko takvih zadataka veƒá ima u periodu
        db.collection(COLLECTION_NAME)
                .whereEqualTo("userId", task.getUserId())
                .whereEqualTo("difficultyXp", diff)
                .whereEqualTo("importanceXp", imp)
                .whereGreaterThanOrEqualTo("creationTimestamp", start.getTimeInMillis())
                .whereLessThan("creationTimestamp", end.getTimeInMillis())
                .get()
                .addOnSuccessListener(querySnapshot -> {
                    long count = querySnapshot.size();
                    Log.d("XP_DEBUG", "üì¶ Pronaƒëeno " + count + " zadataka ove kategorije u periodu.");

                    if (count < maxCount) {
                        task.setXpCounted(true);
                        Log.d("XP_DEBUG", "‚úÖ XP obraƒçunat (pun) za: " + task.getTitle());
                    } else {
                        task.setXpCounted(false);
                        task.setTotalXp(0); // ‚ùó XP se vi≈°e ne dodeljuje, kvota je ispunjena
                        Log.d("XP_DEBUG", "‚ö†Ô∏è Kvota ispunjena ‚Äî XP neƒáe biti dodeljen");
                    }

                    addTask(task);
                })
                .addOnFailureListener(e -> {
                    Log.e("XP_DEBUG", "‚ùå Firestore gre≈°ka: " + e.getMessage());
                    // Fallback ‚Äî upi≈°i task i oznaƒçi kao XP obraƒçunat (da ne gubi≈° podatke)
                    task.setXpCounted(true);
                    addTask(task);
                });
    }


    private int getXpLimit(Task task) {
        int diff = task.getDifficultyXp();
        int imp = task.getImportanceXp();

        if (diff == 1 && imp == 1) return 5;   // Veoma lak + Normalan
        if (diff == 3 && imp == 3) return 5;   // Lak + Va≈æan
        if (diff == 7 && imp == 10) return 2;  // Te≈æak + Ekstremno va≈æan
        if (diff == 20) return 1;              // Ekstremno te≈æak
        if (imp == 100) return 1;              // Specijalan
        return 5;                              // Default fallback
    }

    private boolean isDaily(Task task) {
        int diff = task.getDifficultyXp();
        int imp = task.getImportanceXp();
        return (diff == 1 && imp == 1) || (diff == 3 && imp == 3) || (diff == 7 && imp == 10);
    }

    private boolean isWeekly(Task task) {
        return task.getDifficultyXp() == 20; // ekstremno te≈æak
    }

    private boolean isMonthly(Task task) {
        return task.getImportanceXp() == 100; // specijalan
    }


    public void deleteTask(Task task) {
        // üîπ 1. Ne dozvoli brisanje zavr≈°enih zadataka
        if (task.getStatus() == TaskStatus.FINISHED || task.getStatus() == TaskStatus.CANCELLED) {
            Log.w("Firestore", "‚ùå Zavr≈°en zadatak ne mo≈æe biti obrisan: " + task.getTitle());
            return;
        }

        // üîπ 2. Ako zadatak nije ponavljajuƒái ‚Äî samo obri≈°i dokument
        if (!task.isRecurring()) {
            db.collection(COLLECTION_NAME)
                    .document(task.getId())
                    .delete()
                    .addOnSuccessListener(aVoid ->
                            Log.d("Firestore", "‚úÖ Zadatak obrisan: " + task.getTitle()))
                    .addOnFailureListener(e ->
                            Log.e("Firestore", "‚ùå Gre≈°ka pri brisanju zadatka", e));
            return;
        }

        // üîπ 3. Ako jeste ponavljajuƒái ‚Äî obri≈°i sva buduƒáa ponavljanja
        long now = System.currentTimeMillis();

        db.collection(COLLECTION_NAME)
                .whereEqualTo("recurringGroupId", task.getRecurringGroupId())
                .get()
                .addOnSuccessListener(query -> {
                    for (QueryDocumentSnapshot doc : query) {
                        Task t = doc.toObject(Task.class);
                        if (t.getStartDate() != null && t.getStartDate().getTime() >= now) {
                            db.collection(COLLECTION_NAME)
                                    .document(t.getId())
                                    .delete();
                        }
                    }
                    Log.d("Firestore", "‚úÖ Obrisana buduƒáa ponavljanja za grupu: " + task.getRecurringGroupId());
                })
                .addOnFailureListener(e ->
                        Log.e("Firestore", "‚ùå Gre≈°ka pri brisanju ponavljajuƒáih zadataka", e));
    }
    // üîπ Dohvatanje zadatka po ID-ju
    public LiveData<Task> getTaskById(String taskId) {
        MutableLiveData<Task> liveData = new MutableLiveData<>();

        db.collection(COLLECTION_NAME)
                .document(taskId)
                .addSnapshotListener((snapshot, e) -> {
                    if (e != null || snapshot == null || !snapshot.exists()) {
                        liveData.setValue(null);
                        return;
                    }
                    Task task = snapshot.toObject(Task.class);
                    liveData.setValue(task);
                });

        return liveData;
    }

    // üîπ A≈æuriranje samo statusa zadatka
    public void updateTaskStatus(String taskId, TaskStatus newStatus) {
        db.collection(COLLECTION_NAME)
                .document(taskId)
                .get()
                .addOnSuccessListener(snapshot -> {
                    if (snapshot.exists()) {
                        Task task = snapshot.toObject(Task.class);
                        if (task == null) return;

                        task.setStatus(newStatus);
                        task.setLastActionTimestamp(System.currentTimeMillis());

                        // üîπ 1Ô∏è‚É£ XP se ne obraƒçunava za pauzirane i otkazane zadatke
                        if (newStatus == TaskStatus.PAUSED || newStatus == TaskStatus.CANCELLED) {
                            task.setXpCounted(false);
                            task.setTotalXp(0);
                        }

                        // üîπ 2Ô∏è‚É£ Ako je zadatak oznaƒçen kao uraƒëen
                        else if (newStatus == TaskStatus.FINISHED) {
                            task.setXpCounted(true);

                            // ‚ûï Obavesti TaskService da dodeli XP kroz callback
                            if (taskFinishedListener != null) {
                                taskFinishedListener.onTaskFinished(task.getUserId(), task.getTotalXp());
                            }

                            Log.d("XP_SYSTEM", "‚úÖ Task zavr≈°en: " + task.getTitle() +
                                    " ‚Äî " + task.getTotalXp() + " XP za korisnika " + task.getUserId());
                        }

                        // üîπ 3Ô∏è‚É£ A≈æuriraj u bazi
                        db.collection(COLLECTION_NAME)
                                .document(taskId)
                                .set(task)
                                .addOnSuccessListener(aVoid ->
                                        Log.d("TaskRepository", "‚úÖ Status a≈æuriran: " + newStatus))
                                .addOnFailureListener(e ->
                                        Log.e("TaskRepository", "‚ùå Gre≈°ka pri a≈æuriranju statusa", e));
                    }
                })
                .addOnFailureListener(e ->
                        Log.e("TaskRepository", "‚ùå Gre≈°ka pri preuzimanju zadatka", e));
    }


    /**
     * Raƒçuna success rate za zadatke u trenutnoj etapi (od currentLevelStartTimestamp).
     * Automatski iskljuƒçuje pauzirane, otkazane i zadatke preko kvote (xpCounted = false).
     */
    public void getSuccessRateForCurrentStage(String userId, long currentLevelStartTimestamp, SuccessRateCallback callback) {
        db.collection(COLLECTION_NAME)
                .whereEqualTo("userId", userId)
                .whereGreaterThanOrEqualTo("creationTimestamp", currentLevelStartTimestamp)
                .get()
                .addOnSuccessListener(querySnapshot -> {
                    List<Task> validTasks = new ArrayList<>();
                    int finishedCount = 0;

                    for (QueryDocumentSnapshot document : querySnapshot) {
                        Task task = document.toObject(Task.class);

                        // Iskljuƒçi zadatke preko kvote, pauzirane i otkazane (xpCounted = false)
                        if (!task.isXpCounted()) {
                            continue;
                        }

                        validTasks.add(task);

                        if (task.getStatus() == TaskStatus.FINISHED) {
                            finishedCount++;
                        }
                    }

                    // Izraƒçunaj success rate
                    double successRate;
                    if (validTasks.isEmpty()) {
                        successRate = 67.0; // Default ako nema zadataka u etapi
                    } else {
                        successRate = ((double) finishedCount / validTasks.size()) * 100.0;
                    }

                    Log.d("TaskRepository", "üìä Stage success rate: " + finishedCount + "/" + validTasks.size() + " = " + successRate + "%");
                    callback.onSuccess(successRate);
                })
                .addOnFailureListener(e -> {
                    Log.e("TaskRepository", "‚ùå Error calculating success rate", e);
                    callback.onSuccess(67.0); // Default u sluƒçaju gre≈°ke
                });
    }

    public interface SuccessRateCallback {
        void onSuccess(double successRate);
    }

    public void deleteFutureRecurringTasks(Task task) {
        if (task.getRecurringGroupId() == null) {
            // Ako zadatak nema groupId (tj. nije deo grupe ponavljanja) ‚Äî bri≈°i samo njega
            deleteTask(task);
            return;
        }

        long now = System.currentTimeMillis();

        db.collection(COLLECTION_NAME)
                .whereEqualTo("recurringGroupId", task.getRecurringGroupId())
                .get()
                .addOnSuccessListener(query -> {
                    for (QueryDocumentSnapshot doc : query) {
                        Task t = doc.toObject(Task.class);

                        // Ako je startDate u buduƒánosti ‚Äî obri≈°i
                        if (t.getStartDate() != null && t.getStartDate().getTime() >= now) {
                            db.collection(COLLECTION_NAME)
                                    .document(t.getId())
                                    .delete();
                        }
                    }

                    Log.d("Firestore", "‚úÖ Obrisana buduƒáa ponavljanja za grupu: " + task.getRecurringGroupId());
                })
                .addOnFailureListener(e ->
                        Log.e("Firestore", "‚ùå Gre≈°ka pri brisanju ponavljajuƒáih zadataka", e));
    }

    // üîÅ Dodaj sve instance ponavljajuƒáeg zadatka (uz provjeru baze)
    public void addRecurringTaskInstances(Task baseTask) {
        if (baseTask.getRecurringDates() == null || baseTask.getRecurringDates().isEmpty()) {
            addTaskWithXpLimit(baseTask);
            return;
        }

        if (baseTask.getRecurringGroupId() == null || baseTask.getRecurringGroupId().isEmpty()) {
            baseTask.setRecurringGroupId(java.util.UUID.randomUUID().toString());
        }

        int diff = baseTask.getDifficultyXp();
        int imp = baseTask.getImportanceXp();
        int maxCount = getXpLimit(baseTask);

        // üîπ Odredi vremenski period (isti kao u addTaskWithXpLimit)
        Calendar start = Calendar.getInstance();
        Calendar end = Calendar.getInstance();

        if (isDaily(baseTask)) {
            start.set(Calendar.HOUR_OF_DAY, 0);
            start.set(Calendar.MINUTE, 0);
            start.set(Calendar.SECOND, 0);
            end = (Calendar) start.clone();
            end.add(Calendar.DAY_OF_MONTH, 1);
        } else if (isWeekly(baseTask)) {
            start.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
            start.set(Calendar.HOUR_OF_DAY, 0);
            start.set(Calendar.MINUTE, 0);
            start.set(Calendar.SECOND, 0);
            end = (Calendar) start.clone();
            end.add(Calendar.WEEK_OF_YEAR, 1);
        } else if (isMonthly(baseTask)) {
            start.set(Calendar.DAY_OF_MONTH, 1);
            start.set(Calendar.HOUR_OF_DAY, 0);
            start.set(Calendar.MINUTE, 0);
            start.set(Calendar.SECOND, 0);
            end = (Calendar) start.clone();
            end.add(Calendar.MONTH, 1);
        }

        // üîç 1Ô∏è‚É£ Prebroj postojeƒáe zadatke u bazi za taj period
        db.collection(COLLECTION_NAME)
                .whereEqualTo("userId", baseTask.getUserId())
                .whereEqualTo("difficultyXp", diff)
                .whereEqualTo("importanceXp", imp)
                .whereGreaterThanOrEqualTo("creationTimestamp", start.getTimeInMillis())
                .whereLessThan("creationTimestamp", end.getTimeInMillis())
                .get()
                .addOnSuccessListener(querySnapshot -> {
                    long existingCount = querySnapshot.size();
                    int remaining = (int) (maxCount - existingCount);
                    if (remaining < 0) remaining = 0;

                    Log.d("XP_DEBUG", "üì¶ Veƒá postoji " + existingCount + " zadataka ove vrste. Preostalo: " + remaining);

                    // üîÅ 2Ô∏è‚É£ Kreiraj instance i dodijeli XP prema remaining broju
                    int instanceIndex = 0;
                    for (Long timestamp : baseTask.getRecurringDates()) {
                        Task copy = createTaskCopy(baseTask, timestamp);
                        copy.setCreationTimestamp(System.currentTimeMillis() + instanceIndex);
                        instanceIndex++;

                        if (remaining > 0) {
                            copy.setXpCounted(true);
                            copy.setTotalXp(copy.getDifficultyXp() + copy.getImportanceXp());
                            remaining--;
                            Log.d("XP_DEBUG", "‚úÖ XP obraƒçunat za " + copy.getTitle());
                        } else {
                            copy.setXpCounted(false);
                            copy.setTotalXp(0);
                            Log.d("XP_DEBUG", "‚ö†Ô∏è Kvota ispunjena ‚Äî XP neƒáe biti dodeljen");
                        }

                        addTask(copy);
                        try { Thread.sleep(50); } catch (InterruptedException ignored) {}
                    }
                })
                .addOnFailureListener(e -> Log.e("XP_DEBUG", "‚ùå Firestore gre≈°ka: " + e.getMessage()));
    }

    private Task createTaskCopy(Task baseTask, long timestamp) {
        Task copy = new Task();
        copy.setUserId(baseTask.getUserId());
        copy.setTitle(baseTask.getTitle());
        copy.setDescription(baseTask.getDescription());
        copy.setCategoryId(baseTask.getCategoryId());
        copy.setCategoryName(baseTask.getCategoryName());
        copy.setCategoryColor(baseTask.getCategoryColor());
        copy.setFrequency(baseTask.getFrequency());
        copy.setRecurring(true);
        copy.setRecurringGroupId(baseTask.getRecurringGroupId());
        copy.setInterval(baseTask.getInterval());
        copy.setIntervalUnit(baseTask.getIntervalUnit());
        copy.setStartDate(new Date(timestamp));
        copy.setEndDate(baseTask.getEndDate());
        copy.setTime(baseTask.getTime());
        copy.setStatus(TaskStatus.ACTIVE);
        copy.setDifficultyXp(baseTask.getDifficultyXp());
        copy.setImportanceXp(baseTask.getImportanceXp());
        copy.calculateTotalXp();
        copy.setCreationTimestamp(System.currentTimeMillis());
        return copy;
    }

    private String getPeriodKey(Date date, int diff, int imp) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);

        if (isDaily(new Task(diff, imp))) {
            // npr. "2025-10-21"
            return cal.get(Calendar.YEAR) + "-" + (cal.get(Calendar.MONTH) + 1) + "-" + cal.get(Calendar.DAY_OF_MONTH);
        } else if (isWeekly(new Task(diff, imp))) {
            // npr. "2025-W42"
            return cal.get(Calendar.YEAR) + "-W" + cal.get(Calendar.WEEK_OF_YEAR);
        } else if (isMonthly(new Task(diff, imp))) {
            // npr. "2025-M10"
            return cal.get(Calendar.YEAR) + "-M" + (cal.get(Calendar.MONTH) + 1);
        }
        return "default";
    }


}
